# 方法

|            |                           实例字段                           |                           局部变量                           |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   生存期   |         从实例被创建时开始，直到实例不再被访问时结束         |       从它在块中被声明那一刻开始，在块完成执行时结束。       |
| 隐式初始化 |                    初始化成该类型的默认值                    | 没有隐式初始化。如果变量在使用之前没有被赋值，编译器就会产生一条错误信息。 |
|  存储区域  | 由于实例字段是类的成员，所以所有字段都存储在堆里，无论它们是值类型的还是引用类型的。 | 值类型：存储在栈里<br />引用类型：引用存储在栈里，数据存储在堆里。 |

#### 类型推断和var关键字

var关键字并不是表示特殊变量。它只是语法上的速记，表示任何可以从初始化语句的右边推断出的类型。

使用var关键字的条件：

- 只能用于局部变量，不能用于字段。
- 只能在变量声明中包含初始化时使用。
- 一旦编译器推断出变量的类型，它就是固定且不能更改的。

#### 嵌套块中的局部变量

方法体内部可以嵌套其他的块。

- 可以有任意数量的块，并且它们既可以是顺序的也可以是嵌套的。块可以嵌套到任何级别。
- 局部变量可以在嵌套块的内部声明，并且和所有的局部变量一样，它们的生存期和可见性仅限于声明它们的块及其内嵌块。

在C#中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量。

#### 局部常量

- 在声明时必须初始化
- 在声明后不能改变

语法与字段或变量的声明相同，只有如下两点不同：

- 在类型之前增加关键字const
- 必须有初始化语句。初始化值必须在编译期决定，通常是一个预定义简单类型或由其组成的表达式。它还可以是null引用，但它不能是某对象的引用，因为对象的引用是在运行时决定的。

关键字const不是修饰符，而是核心声明的一部分。它必须直接放在类型的前面。

#### 局部函数

从C#7.0开始，可以在一个方法中声明另一个单独的方法。这样可以将嵌入的方法跟其他代码隔离开来，所以它只能在包含它的方法内调用。如果使用恰当，这可以使代码更清晰，更易于维护。这些嵌入的方法被称为局部函数。

## 参数

形参是局部变量，它声明在方法的参数列表中，而不是在方法体中。

用于初始化形参的表达式或变量称作实参。

#### 值参数

当使用值参数时，通过将实参的值复制到形参的方式把数据传递给方法。方法被调用时，系统执行如下操作：

- 在栈中为形参分配空间。
- 将实参的值复制给形参。

#### 引用参数

- 使用引用参数时，必须在方法的声明和调用中都使用ref修饰符。
- 实参必须是变量，在用作实参前必须被赋值。如果是引用类型变量，可以赋值为一个引用或null。

引用参数特征：

- 不会在栈上为形参分配内存
- 形参的参数名将作为实参变量的别名，指向相同的内存位置

#### 引用类型作为值参数和引用参数

- 将引用类型对象作为值参数传递

  如果在方法内创建一个新对象并赋值给形参，将切断形参与实参之间的关联，并且在方法调用结束后，新对象也将不复存在。

- 将引用类型对象作为引用参数传递

  如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。

## 输出参数

输出参数用于从方法体内把数据传出到调用代码，它们的行为与引用参数类似。

- 必须在声明和调用中都使用修饰符。输出参数的修饰符是out而不是ref。
- 和引用参数相似，实参必须是变量，而不能是其他类型的表达式。因为方法需要内存位置来保存返回值。

```c#
void MyMethod(out int val){...} // 方法声明
...
int y = 1;
MyMethod(out y); // 方法调用
```

与引用参数类似，输出参数的形参充当实参的别名。形参和实参都是同一块内存位置的名称。显然，在方法内对形参做的任何改变在方法执行完成之后（通过实参变量）都是可见的。

- 在方法内部，给输出参数赋值之后才能读取它。这意味着参数的初始值是无关的，并且没有必要在方法调用之前为实参赋值。
- 在方法内部，在方法返回之前，代码中每条可能的路径都必须为所有输出参数赋值。

#### 参数数组

- 在一个参数列表中只能有一个参数数组。
- 如果有，它必须是列表中的最后一个。
- 由参数数组表示的所有参数必须是同一类型。

声明一个参数数组时必须做的事如下：

- 在数据类型前使用params修饰符。
- 在数据类型后放置一组空的方括号。

#### 方法调用

可以使用两种方式为参数数组提供实参

- 一个用逗号分隔的该数据类型元素的列表。所有元素必须是方法声明中指定的类型。

  ```c#
  ListInts(10,20,30);
  ```

- 一个该数据类型元素的一维数组。

  ```c#
  int[] intArray = {1,2,3};
  ListInts(intArray);
  ```

#### 参数类型总结

| 参数类型 | 修饰符 | 是否在声明时使用 | 是否在调用时使用 | 执行                                   |
| -------- | ------ | ---------------- | ---------------- | -------------------------------------- |
| 值       | 无     |                  |                  | 系统把实参的值复制到形参               |
| 引用     | ref    | 是               | 是               | 形参是实参的别名                       |
| 输出     | out    | 是               | 是               | 仅包含一个返回的值。形参是实参的别名。 |
| 数组     | params | 是               | 否               | 允许传递可变数目的实参到方法。         |

#### ref局部变量和ref返回

ref返回功能允许你将一个引用发送到方法外，然后在调用上下文内使用这个引用。

ref局部变量功能的重要事项：

- 可以使用这个功能创建一个变量的别名，即使引用的对象是值类型。
- 对任意一个变量的赋值都会反映到另一个变量上，因为它们引用的是相同的对象，即使是值类型。

创建别名的语法需要使用关键字ref两次，一次是在别名声明的类型的前面，另一次是在赋值运算符的右边，”被别名“的变量的前面：

```c#
ref int y = ref x;
```

```c#
class Simple
{
    private int Score = 5;
    public ref int RefToValue()
    {
        return ref Score;
    }
    public void Display()
    {
        Console.WriteLine($"Value inside class object:{Score}");
    }
}
class Program
{
    static void Main()
    {
        Simple s = new Simple();
        s.Display();
        ref int v1Outside = ref s.RefToValue();
    }
    	v1Outside = 10;
    	s.Display();
	}//好像多了个}？
}
```

- 不能将返回类型是void的方法声明为ref返回方法。
- ref return表达式不能返回如下内容：
  - 空值
  - 常量
  - 枚举成员
  - 类或者结构体的属性
  - 指向只读位置的指针
- ref return表达式只能指向原先就在调用域内的位置，或者字段。它不能指向方法的局部变量。
- ref局部变量只能被赋值一次，一旦初始化就不能指向不同的存储位置了。
- 即使将一个方法声明为ref返回方法，如果在调用该方法时省略了ref关键字，则返回的将是值，而不是指向值的内存位置的指针。
- 如果将ref局部变量作为常规的实际参数传递给其他方法，则该方法仅获取该变量的一个副本。尽管ref局部变量包含指向存储位置的指针，但是当以这种方式使用时，它会传递值而不是引用。

## 方法重载

一个类中可以有多个同名方法，这叫做方法重载，使用相同名称的每个方法必须有一个和其他方法不同的签名。

- 方法的签名由下列信息组成，它们在方法声明的方法头中：
  - 方法的名称
  - 参数的数目
  - 参数的数据类型和顺序
  - 参数修饰符
- 返回类型不是签名的一部分
- 形参的名称也不是签名的一部分

#### 命名参数

C#还允许我们使用命名参数。只要显式指定参数的名字，就可以以任意顺序在方法调用中列出实参。

- 方法的声明没有什么不一样
- 在调用方法时。形参的名字后面跟着冒号和实际的参数值或表达式。

#### 可选参数

所谓可选参数就是可以在调用方法的时候包含这个参数，也可以省略它。为了表明某个参数是可选的，需要在方法声明中为该参数提供默认值。

- 只要值类型的默认值在编译的时候可以确定，就可以使用值类型作为可选参数。
- 只有在默认值为null的时候，引用类型才可以用作可选参数。
- 所有必填参数必须在可选参数声明之前声明。如果有params参数，必须在所有可选参数之后声明。

## 栈帧

在调用方法的时候，内存从栈的顶部开始分配，保存和方法关联的一些数据项。这块内存叫做方法的栈帧。

- 栈帧包含的内存保存如下内容：
  - 返回地址
  - 分配内存的参数，也就是方法的值参数，还可能是参数数组。（如果有的话）
  - 和方法调用相关的其他管理数据项。
- 在方法调用时，整个栈帧都会压入栈。
- 在方法退出的时候，整个栈帧都会从栈上弹出。弹出栈帧有时候也叫作栈展开。

# 深入理解类

## 类成员

类成员声明语句由下列部分组成：核心声明、一组可选的修饰符和一组可选的特性（attribute）

`[特性] [修饰符\] 核心声明`

如果有多个修饰符，可以任意顺序排列。

如果有多个特性，可以任意顺序排列。

## 实例类成员

默认情况下，成员被关联到一个实例。可以认为类的每个实例拥有自己的各个类成员的副本，这些成员称为实例成员。

## 静态字段

- 静态字段被类的所有实例共享，所有实例都访问同一内存位置。如果该内存位置的值被一个实例改变了，这种改变对所有实例都可见。
- 可以使用static修饰符将字段声明为静态。

使用类名.静态字段的方法访问静态成员。

访问静态成员的另一种方法根本不需要使用前缀，只需在该成员所属的类中包含一个using static声明。

```c#
using static System.Console;
using static System.Math;
...
WriteLine($"The square root of 16 is {Sqrt(16)}");
```

### 静态成员的生存期

即使类没有实例，也存在静态成员，并且可以访问。

如果静态字段有初始化语句，那么会在使用该类的任何静态成员之前初始化该字段，但不一定在程序执行的开始就初始化。

## 静态函数成员

- 静态函数成员独立于任何类实例。即使没有类的实例，仍然可以调用静态方法。
- 静态函数成员不能访问实例成员，但能访问其他静态成员。

常量和索引器不能声明为static。

## 成员常量

成员常量类似前一章所述的局部常量，只是它们被声明在类声明中而不是方法内。

C#中没有全局常量，每个常量都必须声明在类型内。

## 常量与静态量

成员常量对类的每个实例都是”可见“的，而且即使没有类的实例也可以使用。与真正的静态量不同，常量没有自己的存储位置，而是在编译时被编译器替换。这种方式类似于C和C++中的#define值。

不能将常量声明为static。

## 属性

属性是代表类实例或类中的数据项的成员。使用属性就像写入或读取一个字段，语法相同。

与字段类似，属性有如下特征：

- 它是命名的类成员
- 它有类型
- 它可以被赋值和读取

然而和字段不同，属性是一个函数成员。

- 它不一定为数据存储分配内存
- 它执行代码

属性是一组（两个）匹配的、命名的、称为访问器的方法。

- set访问器为属性赋值。
- get访问器从属性获取值。

### 属性声明和访问器

set访问器：

- 拥有一个单独的、隐式的值参，名称为value，与属性的类型相同。
- 拥有一个返回类型void

get访问器：

- 没有参数
- 拥有一个与属性类型相同的返回类型。

属性声明的结构：

```java
int MyValue
{
    set
    {
	    CodeToSetPropetyValue
    }
    get
    {
	    CodeToGetPropetyValue
        return SomeInt;
    }
}
```

set访问器中的隐式参数value是一个普通的值参，可以用它发送数据到方法体或访问器块。在块的内部，可以像普通变量那样使用value，包括对它赋值。

- get访问器的所有执行路径必须包含一条return语句，它返回一个属性类型的值。
- 访问set和get可以以任何顺序声明，并且除了这两个访问器外，属性上不允许有其他方法。
- 属性本身没有任何存储。取而代之，访问器决定如何处理发送进来的数据，以及应将什么数据发送出去。在这种情况下，属性使用一个名为TheRealValue的字段作为存储。
- set访问器接受它的输入参数value，并把它的值赋给字段TheRealValue。
- get访问器只是返回字段TheRealValue的值。

#### 使用属性

写入和读取属性的方法与访问字段一样。访问器被隐式调用。

- 要写入一个属性，在赋值语句的左边使用属性的名称。
- 要读取一个属性，把属性的名称用在表达式中。

```java
int MyValue
{
    set{...}
    get{...}
}
...
MyValue = 5;
z = MyValue;
```

属性会根据是写入还是读取来隐式地调用适当的访问器。不能显式地调用访问器，因为这样做会产生编译错误。

```c#
y = MyValue.get();
MyValue.set(5);
```

### 属性和关联字段

属性常和字段关联。一种常见的方式是在类中将字段声明为private以封装该字段，并声明一个public属性来控制从类的外部对该字段的访问。和属性关联的字段被称为后备字段或后备存储。

### 只读和只写属性

要想不定义属性的某个访问器，可以忽略该访问器的声明。

- 只有get访问器----只读
- 只有set访问器----只写
- 两个访问器中至少有一个必须定义

### 属性与公有字段

- 属性是函数成员而不是数据成员，允许你处理输入和输出，而公有字段不行。
- 属性可以只读或只写，而字段不行。
- 编译后的变量和编译后的属性语义不同。

只读属性示例：

```c#
class RightTriangle
{
    public double A = 3;
    public double B = 4;
    public double Hypotenuse
    {
        get{return Math.Sqrt((A*A)+B*B);}
    }
}
```

### 自动实现属性

C#提供了自动实现属性（自动属性），允许只声明属性而不声明后备字段。编译器会为你创建隐藏的后备字段，并且自动挂载到get和set访问器上。

自动属性的要点：

- 不声明后备字段——编译器根据属性的类型分配存储
- 不能提供访问器的方法体——它们必须被简单地声明为分号。

示例：

```c#
class C1
{
    public int MyValue
    {
        set;get;
    }
}
```

### 静态属性

属性也可以声明为static。

- 不能访问类的实例成员，但能被实例成员访问。
- 不管类是否有实例，它们都是存在的。
- 在类的内部，可以仅使用名称来引用静态属性。
- 在类的外部，可以使用类名或者使用using static结构来引用静态属性。

## 实例构造函数

实例构造函数（构造器）是一个特殊的方法，它在创建类的每个新实例时执行。

- 构造函数用于初始化类实例的状态
- 如果希望能从类的外部创建类的实例，需要将构造函数声明为public。
- 构造函数的名称和类名相同
- 构造函数不能有返回值。
- 如果你为类声明了任何构造函数，那么编译器将不会为该类定义默认构造函数。

## 静态构造函数

实例构造函数初始化类的每个新实例，而static构造函数初始化类级别的项。通常，静态构造函数初始化类的静态字段。

类只能有一个静态构造函数，而且不能带参数。

- 类既可以有静态构造函数也可以有实例构造函数。
- 静态构造函数不能访问所在类的实例成员，因此也不能使用this访问器。
- 不能从程序中显式调用静态构造函数，系统会自动调用它们：
  - 在类的任何实例被创建之前
  - 在类的任何静态成员被引用之前。

## 对象初始化语句

对象初始化语句扩展了创建语法，在表达式的尾部放置了一组成员初始化语句。利用对象初始化语句，可以在创建新的对象实例时，设置字段和属性的值。

例如，对于一个名为Point、有两个公有整型字段X和Y的类，可以使用下面的表达式创建一个新对象：

```c#
new Point {X=5,Y=6};
```

- 创建对象的代码必须能够访问要初始化的字段和属性。
- 初始化发生在构造方法执行之后，因此在构造方法中设置的值可能会在之后对象初始化中重置为相同或不同的值。

## readonly修饰符

- const字段只能在字段的声明语句中初始化，而readonly字段可以在下列任意位置设置它的值。
  - 字段声明语句，类似于const
  - 类的任何构造函数。如果是static字段，初始化必须在静态构造函数中完成。
- const字段的值必须可在编译时决定，而readonly字段的值可以在运行时决定。
- const的行为总是静态的，而对于readonly字段以下两点是正确的
  - 它可以是实例字段，也可以是静态字段
  - 它在内存中有存储位置

## this关键字

this关键字在类中使用，是对当前实例的引用。只能被用在下列类成员的代码块中：

- 实例构造函数
- 实例方法
- 属性和索引器的实例访问器
- 用于区分类的成员和局部变量或参数
- 作为调用方法的实参

## 索引器

索引器是一组get和set访问器，与属性类似。可以认为索引器是为类的多个数据成员提供get和set访问的属性。

```c#
class Employee{
    public string LastName;
    public string FirstName;
    public string CityOfBirth;
    public string this[int index]
    {
        set
        {
            switch(index){
                case 0: LastName = value;
                    break;
                case 1: FirstName = value;
                    break;
                case 2: CityOfBirth = value;
                default:
                    throw new ArgumentOutOfRangeException("index");
            }
        }
        get
        {
            switch(index){
                case 0: return LastName;
                case 1: return FirstName;
                case 2:return CityOfBirth;
                default:
                    ArgumentOutOfRangeException("index");
            }
        }
    }
}
```

类中重载的索引器必须有不同的参数列表。

默认情况下，成员的两个访问器的访问级别和成员自身相同。常见范式：将set访问器声明为private，将get访问器声明为public。get之所以是public的，是因为属性的访问级别是public。

- 仅当成员（属性或索引器）既有get访问器也有set访问器时，其访问器才能有访问修饰符。
- 虽然两个访问器都必须出现，但它们中只能有一个有访问修饰符。
- 访问器的访问修饰符的限制必须比成员的访问级别更严格。

## 分部类和分部类型

类的声明可以分割成几个分部类的声明。

- 每个分部类的声明都含有一些类成员的声明
- 类的分布类声明可以在同一个文件中也可以在不同文件中。

每个分部类声明必须被标注为partial class，而不是单独的关键字class。分布类声明看起来和普通类声明相同，只是增加了类型修饰符partial。

对于ASP.NET或Windows Forms：

- 一个文件中的分部类包含由visual studio生成的代码，声明了页面上的组件。你不应该修改这个文件中的分部类，因为在修改页面组件时，visual studio会重新生成它。
- 另外一个文件包含的分部类可用于实现页面或表单组件的外观和行为。

分部方法是声明在分部类中不同部分的方法。分部方法的不同部分可以声明在分部类的不同部分中，也可以声明在同一个部分中。

- 定义分部方法声明
  - 给出签名和返回类型。
  - 声明的实现部分只是一个分号。
- 实现分部方法声明
  - 给出签名和返回类型。
  - 以普通的语句块形式实现。

关于分部方法：

- 定义声明和实现声明的签名和返回类型必须匹配。签名和返回类型有如下特征：
  - 返回类型必须是void
  - 签名不能包括访问修饰符，这使得分部方法是隐式私有的。
  - 参数列表不能包含out参数。
  - 在定义声明和实现声明中都必须包含上下文关键字partial，并且直接放在关键字void之前。

